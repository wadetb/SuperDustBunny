//-----------------------------------------------------------------------------------------------------------------------------------------//
//                                                                                                                                         // 
//                                                          Super Dust Bunny                                                               //
//                                                                                                                                         //
//                               Authors: Thomas Perry <perry.thomas.12@gmail.com> & Wade Brainerd <wadetb@gmail.com>                      //
//                                      Copyright 2010 by Thomas Perry and Wade Brainerd. All rights reserved.                              //
//                                                                                                                                         //
//-----------------------------------------------------------------------------------------------------------------------------------------//
#include "Common.h"
#include "Recorder.h"
#include "Settings.h"
#include "Chapter.h"
#include "Dusty.h"

#ifdef PLATFORM_WINDOWS
#include <winhttp.h>
#pragma comment(lib,"winhttp.lib")
#endif

#ifdef PLATFORM_IPHONE
#include <sys/sysctl.h>
#endif

// TODO:
// + Record session ID, updated each time the game runs.
// + Generate user ids.  Perhaps generated by and then returned by the server the first time a recording is submitted.
// + Score information, once that is implemented.
// + Make a new recording each time the page is restarted.
// + Playback, individual recordings or an entire session.
// + Record available memory.
// + Record settings.


#define MAX_RECORDER_ENTRIES 16384


struct SRecorderHeader
{
	int HeaderVersion;

	int Build;

	char OSVersion[128];
	char ComputerName[128];
	char UserName[128];

	char Chapter[128];
	char Page[128];

	int StartLives;
	int EndLives;
	int EndX;
	int EndY;
	int Result;

    int AvgFPS;
    
	int Duration;
	int NEntries;
};

struct SRecorderEntry
{
	int Timestamp;
	char MoveLeft;
	char MoveRight;
	char Jump;
	char Pad;
};


SRecorderHeader RecorderHeader;
SRecorder Recorder;

int NRecorderEntries;
SRecorderEntry RecorderEntries[MAX_RECORDER_ENTRIES];

int RecordingTime;


void StartRecording()
{
	if (Recorder.RecordingActive)
		ReportError("Cannot start recording when recording is already active.");

	memset(&RecorderHeader, 0, sizeof(RecorderHeader));

	RecorderHeader.HeaderVersion = 2;
	RecorderHeader.Build = 0;

	snprintf(RecorderHeader.Chapter, sizeof(RecorderHeader.Chapter), "%s", Chapter.Name);
	snprintf(RecorderHeader.Page, sizeof(RecorderHeader.Page), "%s", Chapter.Pages[Chapter.PageNum].Name);
	
	RecorderHeader.StartLives = Dusty.Lives;

#ifdef PLATFORM_WINDOWS
	OSVERSIONINFO osvi = { sizeof(OSVERSIONINFO) };
	GetVersionEx(&osvi);

	snprintf(RecorderHeader.OSVersion, sizeof(RecorderHeader.OSVersion), "Windows %d.%d (%d)", osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);
	snprintf(RecorderHeader.ComputerName, sizeof(RecorderHeader.ComputerName), getenv("COMPUTERNAME"));
	snprintf(RecorderHeader.UserName, sizeof(RecorderHeader.UserName), getenv("USERNAME"));
#endif
#ifdef PLATFORM_IPHONE
    [[[UIDevice currentDevice] name] getCString:RecorderHeader.UserName maxLength:sizeof(RecorderHeader.UserName) encoding:NSUTF8StringEncoding];

    size_t size = sizeof(RecorderHeader.ComputerName);
    sysctlbyname("hw.machine", RecorderHeader.ComputerName, &size, NULL, 0);

    NSString *osVersion = [NSString stringWithFormat:@"%@ %@", [[UIDevice currentDevice] systemName], [[UIDevice currentDevice] systemVersion]];
    [osVersion getCString:RecorderHeader.OSVersion maxLength:sizeof(RecorderHeader.OSVersion) encoding:NSUTF8StringEncoding];
#endif

    Recorder.SumFPS = 0;
    Recorder.FPSCount = 0;

	RecordingTime = 0;

	NRecorderEntries = 0;

	Recorder.RecordingActive = true;
}

void StopRecording(ERecordingEndType Result)
{
	if (!Recorder.RecordingActive)
		ReportError("Cannot stop recording when recording is not active.");

	RecorderHeader.Result = Result;
	RecorderHeader.EndLives = Dusty.Lives;
	RecorderHeader.EndX = (int)Dusty.FloatX;
	RecorderHeader.EndY = (int)Dusty.FloatY;

    RecorderHeader.AvgFPS = Recorder.SumFPS / Recorder.FPSCount;
    
	RecorderHeader.Duration = RecordingTime;
	RecorderHeader.NEntries = NRecorderEntries;

	int DataSize = sizeof(SRecorderHeader) + sizeof(SRecorderEntry)*NRecorderEntries;
	char* Data = (char*)malloc(DataSize);
	memcpy(Data, &RecorderHeader, sizeof(SRecorderHeader));
	memcpy(Data + sizeof(SRecorderHeader), RecorderEntries, sizeof(SRecorderEntry) * NRecorderEntries);
    
#ifdef PLATFORM_WINDOWS
	DWORD dwBytesWritten = 0;
	HINTERNET hSession = WinHttpOpen(L"Super Dust Bunny", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
	HINTERNET hConnect = WinHttpConnect(hSession, L"pluszerogames.com", INTERNET_DEFAULT_HTTP_PORT, 0);
	HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"POST", L"/sdb/recording.php", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);

	WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, Data, DataSize, DataSize, 0);
	WinHttpReceiveResponse(hRequest, NULL);

	WinHttpCloseHandle(hRequest);
	WinHttpCloseHandle(hConnect);
	WinHttpCloseHandle(hSession);
#endif
    
#ifdef PLATFORM_IPHONE
    NSData *data = [NSMutableData dataWithBytes:Data length:DataSize];
    
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:
                                    [NSURL URLWithString:
                                     @"http://www.pluszerogames.com/sdb/recording.php"]];
    
    [request setHTTPMethod:@"POST"];
    [request setHTTPBody:data];

    // Asynchronnous:
    [NSURLConnection connectionWithRequest:request delegate:nil];
    
    // Synchronous, for testing:
    //NSURLResponse *response;
    //NSData* result = [NSURLConnection sendSynchronousRequest:request returningResponse:&response error:nil];
    //NSLog(@"HTTP post response:\n%@\n\n", [[NSString alloc] initWithData:result encoding:NSUTF8StringEncoding]);
#endif
    
	free(Data);

	Recorder.RecordingActive = false;
}

bool IsRecordingActive()
{
	return Recorder.RecordingActive;
}

bool IsPlaybackActive()
{
	return false;
}

void StartPlayback()
{
	if (!Recorder.PlaybackActive)
		ReportError("Cannot start playback when playback is already active.");
}

void StopPlayback()
{
	if (!Recorder.PlaybackActive)
		ReportError("Cannot stop playback when playback is not active.");
}

void UpdateRecorder()
{
	if (Recorder.PlaybackActive)
	{
		
	}

	if (Recorder.RecordingActive)
	{
		bool NewEntry = false;

        if (Settings.ControlStyle == CONTROL_TILT)
        {
            bool Jump = GetInput_Jump();
            if (Jump != Recorder.Jump)
            {
                Recorder.Jump = Jump;
                NewEntry = true;	
            }

            bool MoveLeft = GetInput_MoveLeft();
            if (MoveLeft != Recorder.MoveLeft)
            {
                Recorder.MoveLeft = MoveLeft;
                NewEntry = true;	
            }

            bool MoveRight = GetInput_MoveRight();
            if (MoveRight != Recorder.MoveRight)
            {
                Recorder.MoveRight = MoveRight;
                NewEntry = true;	
            }

            if (NewEntry)
            {
                if (NRecorderEntries >= MAX_RECORDER_ENTRIES)
                    ReportError("Exceeded the maximum recording buffer length of %d.", MAX_RECORDER_ENTRIES);
                
                SRecorderEntry* Entry = &RecorderEntries[NRecorderEntries];
                Entry->Timestamp = RecordingTime;
                Entry->Jump = Jump;
                Entry->MoveLeft = MoveLeft;
                Entry->MoveRight = MoveRight;
                
                NRecorderEntries++;
            }
        }
        else
        {
            // SWIPE TODO
        }
	}

	RecordingTime++;
}

