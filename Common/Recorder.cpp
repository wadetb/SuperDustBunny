//-----------------------------------------------------------------------------------------------------------------------------------------//
//                                                                                                                                         // 
//                                                          Super Dust Bunny                                                               //
//                                                                                                                                         //
//                               Authors: Thomas Perry <perry.thomas.12@gmail.com> & Wade Brainerd <wadetb@gmail.com>                      //
//                                      Copyright 2010 by Thomas Perry and Wade Brainerd. All rights reserved.                              //
//                                                                                                                                         //
//-----------------------------------------------------------------------------------------------------------------------------------------//

#include "Common.h"
#include "Recorder.h"
#include "Settings.h"
#include "Chapter.h"
#include "Dusty.h"
#include "Input.h"

#ifdef PLATFORM_WINDOWS
#include <winhttp.h>
#pragma comment(lib,"winhttp.lib")
#endif

#ifdef PLATFORM_IPHONE_OR_MAC
#include <sys/sysctl.h>
#endif

#ifdef PLATFORM_MAC
#import <AddressBook/AddressBook.h>
#endif

// TODO:
// + Record session ID, updated each time the game runs.
// + Generate user ids.  Perhaps generated by and then returned by the server the first time a recording is submitted.
// + Score information, once that is implemented.
// + Record available memory.
// + Record FPS as number / percentage of blown frames.
// + Record game settings.  As DB fields or Blob?
// + Add extra data validation, like CRCs.

#define RECORDER_VERSION 3

#define RECORDER_BUFFER_SIZE (128*1024)
#define MINIMAP_ACTION_BUFFER_SIZE (32*1024)


struct SRecorderHeader
{
	int HeaderVersion;

	int Build;

	char OSVersion[128];
	char ComputerName[128];
	char UserName[128];

	char Chapter[128];
	char Page[128];

	int StartLives;
	int EndLives;
    
	int EndX;
	int EndY;
    
	int Result;

    int AvgFPS;
    
	int Duration;
	int NEvents;
};

struct SRecorderTiltEvent
{
	int Timestamp;
    char MoveLeft;
    char MoveRight;
    char Jump;
    char Pad;
};

struct SRecorderSwipeEvent
{
	int Timestamp;
    float X;
    float Y;
    float Time;
};

struct SRecorderGhostEvent
{
	int Timestamp;
    float X;
    float Y;
    int Sprite;
};


unsigned int BuildNumber = 0x010015 | BUILD_PRERELEASE;

SRecorderHeader RecorderHeader;
SRecorder Recorder;

int NRecorderEvents;
int RecorderEventOffset;
unsigned char RecorderEventBuffer[RECORDER_BUFFER_SIZE];

int RecordingTime;

struct SMinimapHeader
{
    int Version;
    int Width;
    int Height;
    int SolidStride;
    int SolidSize;
    int ActionSize;
};

SMinimapHeader MinimapHeader;
unsigned int* MinimapSolid;
unsigned char* MinimapAction;

int MinimapActionCounter;
int MinimapPrevX;
int MinimapPrevY;


char* GetRecordingChapterName()
{
    return RecorderHeader.Chapter;
}

char* GetRecordingPageName()
{
    return RecorderHeader.Page;
}

int GetRecordingStartLives()
{
    return RecorderHeader.StartLives;
}

void UploadRecording()
{
    if (Recorder.RecordingActive || Recorder.PlaybackActive)
		ReportError("Cannot upload recording when recording or playback is active.");

    int DataSize = 0;
    DataSize += sizeof(SRecorderHeader) + RecorderEventOffset;
    DataSize += sizeof(SMinimapHeader) + MinimapHeader.SolidSize + MinimapHeader.ActionSize;
    
	char* Data = (char*)malloc(DataSize);
    char* CurData = Data;
    
	memcpy(CurData, &RecorderHeader, sizeof(SRecorderHeader));
    CurData += sizeof(SRecorderHeader);
    
	memcpy(CurData, RecorderEventBuffer, RecorderEventOffset);
    CurData += RecorderEventOffset;
    
    memcpy(CurData, &MinimapHeader, sizeof(SMinimapHeader));
    CurData += sizeof(SMinimapHeader);
    
    memcpy(CurData, MinimapSolid, MinimapHeader.SolidSize);
    CurData += MinimapHeader.SolidSize;
    
    memcpy(CurData, MinimapAction, MinimapHeader.ActionSize);
    CurData += MinimapHeader.ActionSize;
    
#ifdef PLATFORM_WINDOWS
	DWORD dwBytesWritten = 0;
	HINTERNET hSession = WinHttpOpen(L"Super Dust Bunny", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
	HINTERNET hConnect = WinHttpConnect(hSession, L"pluszerogames.com", INTERNET_DEFAULT_HTTP_PORT, 0);
	HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"POST", L"/sdb/recording-v3.php", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
    
	WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, Data, DataSize, DataSize, 0);
	WinHttpReceiveResponse(hRequest, NULL);
    
	WinHttpCloseHandle(hRequest);
	WinHttpCloseHandle(hConnect);
	WinHttpCloseHandle(hSession);
#endif
    
#ifdef PLATFORM_IPHONE_OR_MAC
    NSData *data = [NSMutableData dataWithBytes:Data length:DataSize];
    
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:
                                    [NSURL URLWithString:
                                     @"http://www.pluszerogames.com/sdb/recording-v3.php"]];
    
    [request setHTTPMethod:@"POST"];
    [request setHTTPBody:data];
    
    // Asynchronnous:
    [NSURLConnection connectionWithRequest:request delegate:nil];
    
    // Synchronous, for testing:
//    NSURLResponse *response;
//    NSData* result = [NSURLConnection sendSynchronousRequest:request returningResponse:&response error:nil];
//    NSString* resultText = [[NSString alloc] initWithData:result encoding:NSUTF8StringEncoding];
//    NSLog(@"HTTP post response:\n%@\n\n", resultText);
//    [resultText release];
#endif
    
	free(Data);
}

void DownloadRecording(int id)
{
    if (Recorder.RecordingActive || Recorder.PlaybackActive)
		ReportError("Cannot download recording when recording or playback is active.");

#ifdef PLATFORM_WINDOWS
    void* Data = NULL;
    int DataSize = 0;
    
    wchar_t URL[1024];
    _snwprintf(URL, sizeof(URL), L"/sdb/getrecording.php?id=%d", id);

	DWORD dwBytesWritten = 0;
	HINTERNET hSession = WinHttpOpen(L"Super Dust Bunny", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
	HINTERNET hConnect = WinHttpConnect(hSession, L"pluszerogames.com", INTERNET_DEFAULT_HTTP_PORT, 0);
	HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"GET", URL, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
    
	if (!WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, NULL, 0, 0, 0))
        ReportError("Recorder download failed.  Win32 error code: 0x%x", GetLastError());

	if (!WinHttpReceiveResponse(hRequest, NULL))
        ReportError("Recorder download failed.  Win32 error code: 0x%x", GetLastError());
    
    DWORD dwBytesAvailable;
    if (!WinHttpQueryDataAvailable(hRequest, &dwBytesAvailable))
        ReportError("Recorder download failed.  Win32 error code: 0x%x", GetLastError());

    LPVOID lpBytes;
    lpBytes = malloc(dwBytesAvailable);

    DWORD dwBytesRead;
    if (!WinHttpReadData(hRequest, lpBytes, dwBytesAvailable, &dwBytesRead))
        ReportError("Recorder download failed.  Win32 error code: 0x%x", GetLastError());

    Data = lpBytes;
    DataSize = dwBytesRead;

	WinHttpCloseHandle(hRequest);
	WinHttpCloseHandle(hConnect);
	WinHttpCloseHandle(hSession);
#endif
    
#ifdef PLATFORM_IPHONE_OR_MAC
    const void* Data = NULL;
    unsigned long DataSize = 0;
    
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:
                                    [NSURL URLWithString:
                                     [NSString stringWithFormat: @"http://www.pluszerogames.com/sdb/getrecording.php?id=%d", id]]];
    
    [request setHTTPMethod:@"GET"];
    
    NSURLResponse *response;
    NSData* result = [NSURLConnection sendSynchronousRequest:request returningResponse:&response error:nil];
    
    if (!result)
        ReportError("Recorder download failed.");

    Data = [result bytes];
    DataSize = [result length];
#endif

    if (DataSize < sizeof(SRecorderHeader))
        ReportError("Downloaded recorder data is too small to be valid.");

    if (DataSize > sizeof(SRecorderHeader) + RECORDER_BUFFER_SIZE)
        ReportError("Downloaded recorder data is larger than the maximum buffer size %d.", RECORDER_BUFFER_SIZE);
        
    memcpy(&RecorderHeader, Data, sizeof(SRecorderHeader));
    memcpy(RecorderEventBuffer, (char*)Data + sizeof(SRecorderHeader), DataSize - sizeof(SRecorderHeader));
    
    // TODO: Additional checking of downloaded data, CRC or size.

#ifdef PLATFORM_WINDOWS
    free(Data);
#endif
}

void StartRecording()
{
    if (Recorder.RecordingActive || Recorder.PlaybackActive)
		ReportError("Cannot start recording when recording or playback is active.");

	memset(&RecorderHeader, 0, sizeof(RecorderHeader));

	RecorderHeader.HeaderVersion = RECORDER_VERSION;
	RecorderHeader.Build = BuildNumber;

	snprintf(RecorderHeader.Chapter, sizeof(RecorderHeader.Chapter), "%s", Chapter.Name);
	snprintf(RecorderHeader.Page, sizeof(RecorderHeader.Page), "%s", Chapter.Pages[Chapter.PageNum].Name);
	
	RecorderHeader.StartLives = Dusty.Lives;

#ifdef PLATFORM_WINDOWS
	OSVERSIONINFO osvi = { sizeof(OSVERSIONINFO) };
	GetVersionEx(&osvi);

	snprintf(RecorderHeader.OSVersion, sizeof(RecorderHeader.OSVersion), "Windows %d.%d (%d)", osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);
	snprintf(RecorderHeader.ComputerName, sizeof(RecorderHeader.ComputerName), getenv("COMPUTERNAME"));
	snprintf(RecorderHeader.UserName, sizeof(RecorderHeader.UserName), getenv("USERNAME"));
#endif
    
#ifdef PLATFORM_IPHONE
    [[[UIDevice currentDevice] name] getCString:RecorderHeader.UserName maxLength:sizeof(RecorderHeader.UserName) encoding:NSUTF8StringEncoding];

    size_t size = sizeof(RecorderHeader.ComputerName);
    sysctlbyname("hw.machine", RecorderHeader.ComputerName, &size, NULL, 0);

    NSString *osVersion = [NSString stringWithFormat:@"%@ %@", [[UIDevice currentDevice] systemName], [[UIDevice currentDevice] systemVersion]];
    [osVersion getCString:RecorderHeader.OSVersion maxLength:sizeof(RecorderHeader.OSVersion) encoding:NSUTF8StringEncoding];
#endif
    
#ifdef PLATFORM_MAC
    ABPerson *person = [[ABAddressBook sharedAddressBook] me];
    NSString *name = [person valueForProperty:kABFirstNameProperty];
    [name getCString:RecorderHeader.UserName maxLength:sizeof(RecorderHeader.UserName) encoding:NSUTF8StringEncoding];
    
    NSString *computerName = [[NSHost currentHost] localizedName];
    [computerName getCString:RecorderHeader.ComputerName maxLength:sizeof(RecorderHeader.ComputerName) encoding:NSUTF8StringEncoding];    

    SInt32 versionMajor = 0;
    SInt32 versionMinor = 0;
    SInt32 versionBugFix = 0;
    Gestalt( gestaltSystemVersionMajor, &versionMajor );
    Gestalt( gestaltSystemVersionMinor, &versionMinor );
    Gestalt( gestaltSystemVersionBugFix, &versionBugFix );
    NSString *osVersion = [NSString stringWithFormat:@"Mac OS X %d.%d.%d", versionMajor, versionMinor, versionBugFix];
    [osVersion getCString:RecorderHeader.OSVersion maxLength:sizeof(RecorderHeader.OSVersion) encoding:NSUTF8StringEncoding];
#endif


    Recorder.SumFPS = 0;
    Recorder.FPSCount = 0;

	RecordingTime = 0;

	NRecorderEvents = 0;
    RecorderEventOffset = 0;

	Recorder.RecordingActive = true;
}

void StopRecording(ERecordingEndType Result)
{
	if (!Recorder.RecordingActive)
		ReportError("Cannot stop recording when recording is not active.");

	RecorderHeader.Result = Result;
	RecorderHeader.EndLives = Dusty.Lives;
	RecorderHeader.EndX = (int)Dusty.FloatX;
	RecorderHeader.EndY = (int)Dusty.FloatY;

    RecorderHeader.AvgFPS = Recorder.SumFPS / Recorder.FPSCount;
    
	RecorderHeader.Duration = RecordingTime;
	RecorderHeader.NEvents = NRecorderEvents;

	Recorder.RecordingActive = false;

    UploadRecording();
}

bool IsRecordingActive()
{
	return Recorder.RecordingActive;
}

bool IsPlaybackActive()
{
	return Recorder.PlaybackActive;
}

void StartPlayback()
{
	if (Recorder.PlaybackActive)
		ReportError("Cannot start playback when playback is already active.");
    
    RecordingTime = 0;
    RecorderEventOffset = 0;
    NRecorderEvents = 0;
    
    Recorder.PlaybackActive = true;
}

void StopPlayback()
{
	if (!Recorder.PlaybackActive)
		ReportError("Cannot stop playback when playback is not active.");
    
    Recorder.PlaybackActive = false;
}

void UpdateRecorder()
{
	if (Recorder.PlaybackActive)
	{
        while (NRecorderEvents < RecorderHeader.NEvents)
        {
            unsigned char* Pos = RecorderEventBuffer + RecorderEventOffset;
            int Code = *(int*)Pos;
            
            int Type = Code >> 24;
            int Timestamp = Code & 0xffffff;
            
            if ( Timestamp != RecordingTime )
                break;

            if (Type == EVENT_TILT)
            {
                SRecorderTiltEvent* Event = (SRecorderTiltEvent*)Pos;
                Recorder.MoveLeft = Event->MoveLeft != 0;
                Recorder.MoveRight = Event->MoveRight != 0;
                Recorder.Jump = Event->Jump != 0;
                
                RecorderEventOffset += sizeof(SRecorderTiltEvent);
            }
            else if (Type == EVENT_SWIPE_BEGIN || Type == EVENT_SWIPE_POINT || Type == EVENT_SWIPE_END)
            {
                SRecorderSwipeEvent* Event = (SRecorderSwipeEvent*)Pos;
                
                switch (Type)
                {
                    case EVENT_SWIPE_BEGIN: GetInput_BeginSwipe(Event->X, Event->Y, 0); break;
                    case EVENT_SWIPE_POINT: GetInput_AddToSwipe(Event->X, Event->Y, Event->Time); break;
                    case EVENT_SWIPE_END: GetInput_EndSwipe(Event->X, Event->Y, Event->Time); break;
                }
                
                RecorderEventOffset += sizeof(SRecorderSwipeEvent);
            }
            else if (Type == EVENT_GHOST)
            {
                //SRecorderGhostEvent* Event = (SRecorderGhostEvent*)Pos;
                
                //SetDustyGhostState(Event->X, Event->Y, Event->Sprite);
            }

            NRecorderEvents++;
        }
	}

	RecordingTime++;
}

void RecordTiltEvents()
{
    bool NewEntry = false;
    
    if (Settings.ControlStyle == CONTROL_TILT)
    {
        bool Jump = GetInput_Jump();
        if (Jump != Recorder.Jump)
        {
            Recorder.Jump = Jump;
            NewEntry = true;	
        }
        
        bool MoveLeft = GetInput_MoveLeft();
        if (MoveLeft != Recorder.MoveLeft)
        {
            Recorder.MoveLeft = MoveLeft;
            NewEntry = true;	
        }
        
        bool MoveRight = GetInput_MoveRight();
        if (MoveRight != Recorder.MoveRight)
        {
            Recorder.MoveRight = MoveRight;
            NewEntry = true;	
        }
        
        if (NewEntry)
        {
            if (RecorderEventOffset + sizeof(SRecorderTiltEvent) >= RECORDER_BUFFER_SIZE)
                ReportError("Exceeded the maximum recording buffer size of %d.", RECORDER_BUFFER_SIZE);
            
            SRecorderTiltEvent* Event = (SRecorderTiltEvent*)( RecorderEventBuffer + RecorderEventOffset );
            Event->Timestamp = RecordingTime | (EVENT_TILT<<24);
            Event->Jump = Jump;
            Event->MoveLeft = MoveLeft;
            Event->MoveRight = MoveRight;
            
            RecorderEventOffset += sizeof(SRecorderTiltEvent);
            NRecorderEvents++;
        }
    }
}

void RecordSwipeEvent(int Type, float X, float Y, float Time)
{
    if (RecorderEventOffset + sizeof(SRecorderSwipeEvent) >= RECORDER_BUFFER_SIZE)
        ReportError("Exceeded the maximum recording buffer size of %d.", RECORDER_BUFFER_SIZE);
    
    SRecorderSwipeEvent* Event = (SRecorderSwipeEvent*)( RecorderEventBuffer + RecorderEventOffset );
    Event->Timestamp = RecordingTime | (Type<<24);
    Event->X = X;
    Event->Y = Y;
    Event->Time = Time;
    
    RecorderEventOffset += sizeof(SRecorderSwipeEvent);
    NRecorderEvents++;
}

void RecordGhostEvent(float X, float Y, int Sprite)
{
    if (RecorderEventOffset + sizeof(SRecorderGhostEvent) >= RECORDER_BUFFER_SIZE)
        ReportError("Exceeded the maximum recording buffer size of %d.", RECORDER_BUFFER_SIZE);
    
    SRecorderGhostEvent* Event = (SRecorderGhostEvent*)( RecorderEventBuffer + RecorderEventOffset );
    Event->Timestamp = RecordingTime | (EVENT_GHOST<<24);
    Event->X = X;
    Event->Y = Y;
    Event->Sprite = Sprite;
    
    RecorderEventOffset += sizeof(SRecorderSwipeEvent);
    NRecorderEvents++;
}

void InitMinimap()
{
    MinimapActionCounter = 0;
    MinimapPrevX = ((int)Dusty.FloatX)/8;
    MinimapPrevY = ((int)Dusty.FloatY)/8;
    
    MinimapHeader.Version = 1;
    MinimapHeader.Width = Chapter.PageWidth;
    MinimapHeader.Height = Chapter.PageHeight;

    if (MinimapSolid)
        free(MinimapSolid);
    if (MinimapAction)
        free(MinimapAction);
    
    MinimapHeader.SolidStride = ((MinimapHeader.Width+31)/32) * sizeof(unsigned int);
    MinimapHeader.SolidSize = MinimapHeader.SolidStride * MinimapHeader.Height;
    
    MinimapSolid = (unsigned int*)malloc(MinimapHeader.SolidSize);
    memset(MinimapSolid, 0, MinimapHeader.SolidSize);
    
    for (int y = 0; y < MinimapHeader.Height; y++)
        for (int x = 0; x < MinimapHeader.Width; x++)
            MinimapSolid[MinimapHeader.SolidStride/4 * y + x/32] |= (1<<(x&31)) * IsBlockSolid(x, y);    

    MinimapAction = (unsigned char*)malloc(MINIMAP_ACTION_BUFFER_SIZE);
    memset(MinimapAction, 0, MINIMAP_ACTION_BUFFER_SIZE);
    
    MinimapHeader.ActionSize = 0;
    
    MinimapAction[MinimapHeader.ActionSize++] = MinimapPrevX & 0xff;
    MinimapAction[MinimapHeader.ActionSize++] = (MinimapPrevX>>8) & 0xff;
    MinimapAction[MinimapHeader.ActionSize++] = MinimapPrevY & 0xff;
    MinimapAction[MinimapHeader.ActionSize++] = (MinimapPrevY>>8) & 0xff;
}

void UpdateMinimap(EMinimapAction Action)
{
    if (Action == MINIMAP_NORMAL)
    {
        if (MinimapActionCounter % 10 != 0)
            return;
    }
    
    int CurX = ((int)Dusty.FloatX)/8;
    int CurY = ((int)Dusty.FloatY)/8;
    
    int DeltaX = CurX - MinimapPrevX;
    int DeltaY = CurY - MinimapPrevY;

    if (DeltaX > 127) DeltaX = 127;
    if (DeltaX < -128) DeltaX = -128;
    if (DeltaY > 127) DeltaY = 127;
    if (DeltaY < -128) DeltaY = -128;
    
    MinimapPrevX += DeltaX;
    MinimapPrevY += DeltaY;
    
    if (MinimapHeader.ActionSize+3 >= MINIMAP_ACTION_BUFFER_SIZE)
        return;
    
    MinimapAction[MinimapHeader.ActionSize++] = DeltaX;
    MinimapAction[MinimapHeader.ActionSize++] = DeltaY;
    MinimapAction[MinimapHeader.ActionSize++] = Action;
}
